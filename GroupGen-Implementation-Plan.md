# GroupGen 구현 계획서

## 개요
기존 GroupGen 구현의 복잡성과 변경점을 최소화하기 위해 새로운 접근 방식으로 재구현합니다.

## 설계 원칙
1. **최소 변경**: 기존 코드 구조를 최대한 유지
2. **프롬프트 보존**: PM이 전달한 프롬프트는 절대 변경하지 않음
3. **단순성**: 복잡한 의존성과 서비스 분리 최소화
4. **안정성**: 검증된 기존 패턴 재사용

## 구현 방향

### 1. 기존 코드 분석 및 참고
- 현재 `feat/#691_belljun3395` 브랜치의 구현 내용 분석
- 재사용 가능한 코드 패턴 및 로직 식별
- 프롬프트 관련 코드는 그대로 유지

### 2. 단순화된 아키텍처
```
GroupSchedulingUseCase (기존 스케줄링 로직 활용)
├── GroupGenService (통합된 그룹 생성 서비스)
│   ├── 키워드 추출 (KeyWordsService 활용)
│   ├── 그룹화 로직 (headline + keywords 기반)
│   ├── 헤드라인 생성
│   ├── 요약 생성
│   └── 하이라이트 생성
└── GroupGenRepository (기존 repository 패턴 활용)
```

### 3. 구현 단계

#### Phase 1: 기본 구조 구현
- [ ] `GroupGen` 엔티티 정의 (기존 패턴 따라)
- [ ] `GroupGenRepository` 인터페이스 생성
- [ ] `GroupGenService` 기본 골격 구현
- [ ] `GroupSourceHeadlinesConverter` 재사용
- [ ] API 엔드포인트 `/contents/schedule/group` 추가

#### Phase 2: 그룹 생성 로직
- [ ] 기존 `KeyWordsService` 그대로 활용하여 키워드 추출
- [ ] `headline + keywords` 기반 그룹화 로직 구현
- [ ] 프롬프트 호출 부분은 기존 코드 그대로 사용
- [ ] 데이터 변환 로직 최소화

#### Phase 3: 스케줄링 통합
- [ ] 기존 `SchedulingUseCase` 패턴 활용
- [ ] `GroupSchedulingUseCase` 구현 (새벽 5시 실행)
- [ ] 동시성 제어는 기존 방식 그대로 적용 (atomic concurrency control)
- [ ] 4시 콘텐츠 생성 의존성 확인

#### Phase 4: 테스트 및 검증
- [ ] 기존 테스트 코드 패턴 참고하여 단위 테스트 작성
- [ ] 통합 테스트 구현
- [ ] 성능 검증

## 주요 변경 사항 최소화 전략

### 1. 기존 코드 재사용
- **키워드 추출**: `KeyWordsService` 100% 재사용
- **프롬프트 생성 로직**: 100% 재사용 (키워드 추출, 그룹화, 헤드라인, 요약, 하이라이트)
- **데이터베이스 접근 패턴**: 기존 Repository 패턴 활용
- **스케줄링 로직**: 기존 `@Scheduled` 방식 그대로 사용
- **JSON 변환**: `GroupSourceHeadlinesConverter` 재사용
- **프롬프트 상수**: `PromptConstants` 재사용 (DEFAULT_TARGET_PERCENTAGE = 30, MIN_GROUP_SIZE = 3)

### 2. 서비스 통합
- 기존의 여러 서비스로 분리된 구조를 하나의 `GroupGenService`로 통합
- `KeyWordsService`는 독립적으로 유지 (재사용)
- 복잡한 의존성 관계 제거
- 단순한 메서드 호출 체인으로 변경

### 3. 데이터 모델 단순화
- 기존 `GroupGen` 엔티티 구조를 참고하되 필요한 필드만 유지
- JSON 변환 로직을 기존 패턴에 맞게 구현
- 인덱싱 전략은 기존 방식 그대로 적용

## 프롬프트 보존 전략

### 1. 프롬프트 코드 격리
- 프롬프트 관련 클래스는 별도 패키지로 관리
- 기존 프롬프트 텍스트는 절대 수정하지 않음
- 프롬프트 호출 인터페이스만 필요시 조정

### 2. 검증 체계
- 프롬프트 변경 사항에 대한 명시적 검증
- PM 승인 없이는 프롬프트 관련 코드 변경 금지
- 코드 리뷰 시 프롬프트 변경 사항 강조

## 예상 위험 요소 및 대응

### 1. 기존 로직 호환성
- **위험**: 기존 로직과 새 구현 간 결과 차이
- **대응**: 기존 코드 로직을 최대한 그대로 이식

### 2. 성능 이슈
- **위험**: 서비스 통합으로 인한 성능 저하
- **대응**: 기존 성능 지표 기준으로 벤치마킹

### 3. 테스트 커버리지
- **위험**: 단순화로 인한 테스트 누락
- **대응**: 기존 테스트 케이스 모두 포함하여 재구현

### 4. 스케줄링 의존성
- **위험**: 4시 콘텐츠 생성과 5시 그룹 생성 간 타이밍 이슈
- **대응**: 기존 동시성 제어 방식 그대로 적용

### 5. JSON 직렬화 오류
- **위험**: `GroupSourceHeadlinesConverter`에서 직렬화 실패
- **대응**: 기존 에러 처리 로직 그대로 유지

## 완료 기준

### 1. 기능적 완료
- [ ] 모든 기존 기능 동일하게 동작
- [ ] 프롬프트 결과 일치성 확인
- [ ] 스케줄링 정상 동작 확인

### 2. 품질 완료
- [ ] 단위 테스트 커버리지 80% 이상
- [ ] 통합 테스트 통과
- [ ] 성능 기준 만족

### 3. 문서화 완료
- [ ] 코드 주석 추가
- [ ] API 문서 업데이트
- [ ] 운영 가이드 작성

## PR #693 분석 결과 반영사항

### 1. 기존 구현에서 파악된 핵심 요소
- **스케줄링**: 새벽 5시 실행 (4시 콘텐츠 생성 이후)
- **동시성 제어**: atomic concurrency control 적용
- **프롬프트 상수**: DEFAULT_TARGET_PERCENTAGE = 30, MIN_GROUP_SIZE = 3
- **API 엔드포인트**: `/contents/schedule/group`
- **아키텍처 개선**: 206라인 UseCase를 여러 서비스로 분리했던 경험

### 2. 재사용할 핵심 컴포넌트
- `GroupSourceHeadlinesConverter` (JSON 직렬화)
- `PromptConstants` (그룹화 관련 상수)
- `GroupPromptGenerator` (프롬프트 생성 로직)
- 동시성 제어 로직
- 에러 처리 및 로깅 패턴

### 3. 주의사항
- 복잡한 UseCase 분리로 인한 오버엔지니어링 방지
- Gson 통합 시 기존 ObjectMapper와의 호환성 확인
- 키워드 추출 기능의 중요성 (그룹화 정확도 향상)

## 다음 단계
1. 기존 코드 상세 분석
2. 프롬프트 코드 추출 및 격리
3. 단순화된 서비스 구현
4. 테스트 및 검증
5. 문서화 완료

---
*작성일: 2025-07-04*  
*작성자: belljun3395*  
*브랜치: #691_new_belljun3395*